# 正则表达式

在编程语言中，正则表达式用于匹配指定的字符串。 通过正则表达式创建匹配模式（规则）可以帮你完成指定匹配。

```js
let email = /^\w+@\w+(.\w+)*(.\w+)$/;
let id = /^[1-9]\d{5}[1-9]\d{3}((0[1-9])|(1[0-2]))(([0-2]\d)|(3[01]))\d{3}[\dX]$/
```



## 测试方法

JavaScript 中有多种使用正则表达式的方法。 测试正则表达式的一种方法是使用 `.test()` 方法。 `.test()` 方法会把编写的正则表达式和字符串（即括号内的内容）匹配，如果成功匹配到字符，则返回 `true`，反之，返回 `false`。

使用 `.test()` 方法，检测字符串 `myString` 是否符合正则表达式 `myRegex` 定义的规则。

## 同时用多种模式匹配文字字符串

可以使用 `alternation` 或 `OR` 操作符搜索多个模式： `|`

此操作符匹配操作符前面或后面的字符。 例如，如果想匹配 `yes` 或 `no`，需要的正则表达式是 `/yes|no/`。

## 忽略大小写

可以使用标志（flag）来匹配大小写的情况。 标志有很多，忽略大小写的标志——`i`。

可以通过将它附加到正则表达式之后来使用它。 这里给出使用该标志的一个实例 `/ignorecase/i`。 这个字符串可以匹配字符串 `ignorecase`、`igNoreCase` 和 `IgnoreCase`。

## 提取匹配项

可以使用字符串来调用 `.match()` 方法，并在括号内传入正则表达式。

 `.match` 语法是目前为止一直使用的 `.test` 方法中的“反向”：

```js
'string'.match(/regex/);
/regex/.test('string');
```

## 全局匹配

若要多次搜寻或提取模式匹配，可以使用 `g` 标志。

```js
let repeatRegex = /Repeat/g;
testStr.match(repeatRegex);
```

这里 `match` 返回值 `["Repeat", "Repeat", "Repeat"]`

**注意：**
在正则表达式上可以有多个标志，比如 `/search/gi`

## **用通配符匹配任何内容**

有时不（或不需要）知道匹配模式中的确切字符。 如果要精确匹配到完整的单词，那出现一个拼写错误就会匹配不到。 可以使用通配符 `.` 来处理这种情况。

通配符 `.` 将匹配任何一个字符。 通配符也叫 `dot` 或 `period`。 可以像使用正则表达式中任何其他字符一样使用通配符。

## **将单个字符与多种可能性匹配**

可以使用字符集 （character classes）更灵活的匹配字符。 可以把字符集放在方括号（`[` 和 `]`）之间来定义一组需要匹配的字符串。

例如，如果想要匹配 `bag`、`big` 和 `bug`，但是不想匹配 `bog`。 可以创建正则表达式 `/b[aiu]g/` 来执行此操作。 `[aiu]` 是只匹配字符 `a`、`i` 或者 `u` 的字符集。

## **匹配字母表中的字母**

在字符集中，可以使用连字符（`-`）来定义要匹配的字符范围。

例如，要匹配小写字母 `a` 到 `e`，你可以使用 `[a-e]`。

```js
let catStr = "cat";
let batStr = "bat";
let matStr = "mat";
let bgRegex = /[a-e]at/;
catStr.match(bgRegex);
batStr.match(bgRegex);
matStr.match(bgRegex);
```

按顺序排列，三次 `match` 调用将返回值 `["cat"]`，`["bat"]` 和 `null`。

使用连字符（`-`）匹配字符范围并不仅限于字母。 它还可以匹配一系列数字。

例如，`/[0-5]/` 匹配 `0` 和 `5` 之间的任意数字，包含 `0` 和 `5`。

此外，还可以在单个字符集中组合一系列字母和数字。

```js
let jennyStr = "Jenny8675309";
let myRegex = /[a-z0-9]/ig;
jennyStr.match(myRegex);
```

## **匹配单个未指定的字符**

可以创建一个不想匹配的字符集合。 这些类型的字符集称为否定字符集（ negated character sets）。

要创建否定字符集，需要在==开始括号后面==和不想匹配的字符前面放置脱字符（即`^`）。

例如，`/[^aeiou]/gi` 匹配所有非元音字符。 注意，字符 `.`、`!`、`[`、`@`、`/` 和空白字符等也会被匹配，该否定字符集仅排除元音字符。

## **匹配出现一次或多次的字符**

`/a+/g` 会在 `abc` 中匹配到一个匹配项，并且返回 `["a"]`。 因为 `+` 的存在，它也会在 `aabc` 中匹配到一个匹配项，然后返回 `["aa"]`。

如果它是检查字符串 `abab`，它将匹配到两个匹配项并且返回`["a", "a"]`，因为`a`字符不连续，在它们之间有一个`b`字符。 最后，因为在字符串 `bcd` 中没有 `a`，因此找不到匹配项。

还有一个选项可以匹配出现零次或多次的字符。执行该操作的字符叫做星号，即`*`。

## **用惰性匹配来查找字符**

在正则表达式中，贪婪（greedy）匹配会匹配到符合正则表达式匹配模式的字符串的最长可能部分，并将其作为匹配项返回。 另一种方案称为懒惰（lazy）匹配，它会匹配到满足正则表达式的字符串的最小可能部分。

可以将正则表达式 `/t[a-z]*i/` 应用于字符串 `"titanic"`。 这个正则表达式是一个以 `t` 开始，以 `i` 结束，并且中间有一些字母的匹配模式。

正则表达式默认是贪婪匹配，因此匹配返回为 `["titani"]`。 它会匹配到适合该匹配模式的最大子字符串。

但是，你可以使用 `?` 字符来将其变成懒惰匹配。 调整后的正则表达式 `/t[a-z]*?i/` 匹配字符串 `"titanic"` 返回 `["ti"]`。

## **匹配字符串的开头**

使用字符集中前插入符号（`^`）来创建一个否定字符集，形如 `[^thingsThatWillNotBeMatched]`。 除了在字符集中使用之外，脱字符还用于匹配字符串的开始位置。

```js
let firstString = "Ricky is first and can be found.";
let firstRegex = /^Ricky/;
firstRegex.test(firstString);
let notFirst = "You can't find Ricky now.";
firstRegex.test(notFirst);
```

第一次 `test` 调用将返回 `true`，而第二次调用将返回 `false`。

## **匹配字符串的末尾**

可以使用正则表达式的美元符号 `$` 来搜寻字符串的结尾。

```js
let theEnding = "This is a never ending story";
let storyRegex = /story$/;
storyRegex.test(theEnding);
let noEnding = "Sometimes a story will have to end";
storyRegex.test(noEnding);
```

第一次 `test` 调用将返回 `true`, 而第二次调用将返回 `false`。

## **匹配所有的字母和数字**

使用元字符，可以使用 `[a-z]` 搜寻字母表中的所有字母。 这种元字符是很常见的，它有一个缩写，但这个缩写也包含额外的字符。

JavaScript 中与字母表匹配的最接近的元字符是`\w`。 这个缩写等同于`[A-Za-z0-9_]`。 此字符类匹配上面字母和小写字母以及数字。 注意，这个字符类也包含下划线字符 (`_`)。

这些元字符缩写也被称为短语元字符 shorthand character classes。

## **匹配除了字母和数字的所有符号**

可以使用 `\W` 搜寻和 `\w` 相反的匹配模式。 注意，相反匹配模式使用大写字母。 此缩写与 `[^A-Za-z0-9_]` 是一样的。

## **匹配所有数字**及非数字

查找数字字符的缩写是 `\d`，注意是小写的 `d`。 这等同于元字符 `[0-9]`，它查找 0 到 9 之间任意数字的单个字符。

查找非数字字符的缩写是 `\D`。 这等同于字符串 `[^0-9]`，它查找不是 0 - 9 之间数字的单个字符。

**例题**

1. 用户名只能是数字字母字符。

2. 用户名中的数字必须在最后。 数字可以有零个或多个。 用户名不能以数字开头。

3. 用户名字母可以是小写字母和大写字母。

4. 用户名长度必须至少为两个字符。 两位用户名只能使用字母。

   ​	```/^[a-z][a-z]+\d*$|^[a-z]\d\d+$/i```

## **匹配空白字符**

可以使用 `\s` 搜寻空格，其中 `s` 是小写。 此匹配模式将匹配空格、回车符、制表符、换页符和换行符。 可以认为这类似于元字符 `[ \r\t\f\n\v]`。

使用 `\S` 搜寻非空白字符，其中 `s` 是大写。 此匹配模式将不匹配空格、回车符、制表符、换页符和换行符。 可以认为这类似于元字符 `[^ \r\t\f\n\v]`。

## **指定匹配的上限和下限**

可以使用数量说明符（quantity specifiers）指定匹配模式的上下限。 数量说明符与花括号（`{` 和 `}`）一起使用。 可以在花括号之间放两个数字，这两个数字代表匹配模式的上限和下限。

例如，要匹配出现 `3` 到 `5` 次字母 `a` 的在字符串 `ah`，正则表达式应为`/a{3,5}h/`。

可以使用带有花括号的数量说明符来指定匹配模式的上下限。 但有时候只想指定匹配模式的下限而不需要指定上限。

为此，在第一个数字后面跟一个逗号即可。

例如，要匹配至少出现 `3` 次字母 `a` 的字符串 `hah`，正则表达式应该是 `/ha{3,}h/`。

要指定一定数量的匹配模式，只需在大括号之间放置一个数字。

例如，要只匹配字母 `a` 出现 `3` 次的单词`hah`，正则表达式应为`/ha{3}h/`。

## **检查全部或无**

可以使用问号 `?` 指定可能存在的元素。 这将检查前面的零个或一个元素。 可以将此符号视为前面的元素是可选的。

例如，美式英语和英式英语略有不同，可以使用问号来匹配两种拼写。

```js
let american = "color";
let british = "colour";
let rainbowRegex= /colou?r/;
rainbowRegex.test(american);
rainbowRegex.test(british);
```

## **正向先行断言和负向先行断言**

先行断言 （Lookaheads）是告诉 JavaScript 在字符串中向前查找的匹配模式。 当想要在同一个字符串上搜寻多个匹配模式时，这可能非常有用。

有两种先行断言：正向先行断言（positive lookahead）和负向先行断言（negative lookahead）。

正向先行断言会查看并确保搜索匹配模式中的元素存在，但实际上并不匹配。 正向先行断言的用法是 `(?=...)`，其中 `...` 就是需要存在但不会被匹配的部分。

另一方面，负向先行断言会查看并确保搜索匹配模式中的元素不存在。 负向先行断言的用法是 `(?!...)`，其中 `...` 是希望不存在的匹配模式。 如果负向先行断言部分不存在，将返回匹配模式的其余部分。

## **检查混合字符组**

如果想在字符串找到 `Penguin` 或 `Pumpkin`，可以用这个正则表达式：`/P(engu|umpk)in/g`。

## **使用捕获组重用模式**

一些所搜寻的匹配模式会在字符串中出现多次。 手动重复该正则表达式显得不够简洁。 当字符串中出现多个重复子字符串时，有一种更好的方式来编写模式。

可以使用捕获组（capture groups）搜寻重复的子字符串。 括号 `(` 和 `)` 可以用来匹配重复的子字符串。 把需要重复匹配的模式放在括号中即可。

要指定重复字符串将出现的位置，可以使用反斜杠（`\`）后接一个数字。 这个数字从 1 开始，随着你使用的每个捕获组的增加而增加。 这里有一个示例，`\1` 可以匹配第一个组。

**例题**

在 `reRegex` 中使用捕获组来匹配一个只由相同的数字重复三次组成的由空格分隔字符串。

```js
let repeatNum = "42 42 42";
let reRegex = /^(\d+)\s\1\s\1$/; 
let result = reRegex.test(repeatNum);
```

## **使用捕获组搜索和替换**

可以在字符串上使用 `.replace()` 方法来搜索并替换字符串中的文本。 `.replace()` 的输入首先是想要搜索的正则表达式匹配模式。 第二个参数是用于替换匹配的字符串或用于执行某些操作的函数。

还可以使用美元符号（`$`）访问替换字符串中的捕获组。

```js
"Code Camp".replace(/(\w+)\s(\w+)/, '$2 $1');
```

调用 `replace` 将返回字符串 `Camp Code`。

**例题**

编写一个正则表达式并使用适当的字符串方法删除字符串开头和结尾的空格。

```js
let hello = "   Hello, World!  ";
let wsRegex = /^\s+|\s+$/g;
let result = hello.replace(wsRegex, '');
```

# 要点

`*`匹配模式为贪婪匹配 `*?`将其改为懒惰匹配

`\w`匹配所有字母及数字，`\W`匹配所有非字母及非数字

`\d`匹配所有数字，`\D`匹配所有非数字

`\s`匹配空格、回车、制表等`\r\t\f\n\v`，`\S`匹配非空字符

 数量说明符与花括号（`{` 和 `}`）一起使用。如：`{1,100}`，==上限可为空==，==一个数字为指定数量==

**先行断言(不影响匹配结果)：**

​	`(?=...)`条件存在后继续匹配

​	`(?!...)`条件不存在后继续匹配

括号`()`中的内容会按顺序编组`eg: \1 \2 ...`，之后引用时可以用用编号代替

String.replace中可以用`$`选择编组

``$$ ：插入一个 “$”。
$& ：插入匹配的子串。
$` ：插入当前匹配的子串左边的内容。
$’ ：插入当前匹配的子串右边的内容。``

```js
wrongText.replace(silverRegex, "blue");//普通替换
```

```js
"Code Camp".replace(/(\w+)\s(\w+)/, '$2$1');//选择编组 返回'CampCode'
```





